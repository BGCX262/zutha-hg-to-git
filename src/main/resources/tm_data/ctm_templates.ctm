%prefix zsi http://psi.zutha.net/
%prefix ztm http://psi.topicmap.zutha.net/

# ==================== General Purpose Templates ====================

# ITEM PLAYS ROLE
def plays-role($item, $role)
    zsi:item-plays-role($item,$role);
end
def played-by($role,$item)
    zsi:item-plays-role($item,$role);
end

# ITEM PROPERTY
def property($item, $propType, $value)
    ?propReifier isa $propType.

    $item
    $propType: $value ~ ?propReifier.
end

# ITEM PROPERTY WITH PERMISSION
def property($item, $propType, $value, $permLevel)
    ?propReifier isa $propType;
        zsi:permission-level: $permLevel.

    $item
    $propType: $value ~ ?propReifier.
end


# ==================== Schema Templates ====================

# OVERLAP DECLARATION
def overlaps($itemType1, $itemType2)
    ?assoc isa zsi:overlap-declaration.

    zsi:overlap-declaration(
        zsi:item-type : $itemType1,
        zsi:item-type : $itemType2
    ) ~ ?assoc
end

# ITEM TYPE ROLE DECLARATION
def cannot-play-role($itemType, $role)
    declares-role($itemType, $role, 0, 0)
end
def may-play-role($itemType, $role)
    declares-role($itemType, $role, 0, 1)
end
def must-play-role($itemType, $role)
    declares-role($itemType, $role, 1, 1)
end
def cannot-be-played-by(role, $itemType)
    cannot-play-role($itemType, $role)
end
def may-be-played-by(role, $itemType)
    can-play-role($itemType, $role)
end
def must-be-played-by(role, $itemType)
    must-play-role($itemType, $role)
end
def declares-role($itemType, $role, $min, $max)
    ?assoc isa zsi:item-type-role-declaration;
        zsi:role-card-min: $min;
        zsi:role-card-max: $max;
    .
    zsi:item-type-role-declaration(
        zsi:item-type: $itemType,
        zsi:role: $role,
    ) ~ ?assoc
end


# PROPERTY DECLARATION
def has-property($itemType, $propType, $min, $max)
    ?assoc isa zsi:property-declaration;
        zsi:property-card-min: $min;
        zsi:property-card-max: $max;
    .
    zsi:property-declaration(
        zsi:item-type: $itemType,
        zsi:property-type: $propType
    ) ~ ?assoc
end

# PROPERTY DATA TYPE CONSTRAINT
def has-datatype($propType, $dataType)
    ?assoc isa zsi:property-datatype-constraint;
        zsi:datatype: $dataType;
    .
    zsi:property-datatype-constraint(
        zsi:property-type: $propType
    ) ~ ?assoc
end

# ASSOCIATION ROLE CONSTRAINT
def has-role($assocType, $assocMin, $assocMax, $role, $roleMin, $roleMax)
    ?assoc isa zsi:association-role-constraint;
        zsi:association-card-min: $assocMin;
        zsi:association-card-max: $assocMax;
        zsi:role-card-min: $roleMin;
        zsi:role-card-max: $roleMax;
    .
    zsi:association-role-constraint(
        zsi:association-type: assocType,
        zsi:role: $role
    ) ~ ?assoc
end
def has-association($role, $roleMin, $roleMax, $assocType, $assocMin, $assocMax)
    has-role($assocType, $assocMin, $assocMax, $role, $roleMin, $roleMax)
end

# ROLE COMBINATION CONSTRAINT
def role-combination($assocType,
        $role1,$itemType1,$role2,$itemType2)
    ?combo isa zsi:role-combination;
    .
    zsi:association-has-role-combination-constraint(
        zsi:role-combination: ?combo,
        zsi:association-type: $assocType
    )
    zsi:role-combination-constraint(
        zsi:role-combination: ?combo,
        zsi:role: $role1,
        zsi:item-type: $itemType1
    )
    zsi:role-combination-constraint(
        zsi:role-combination: ?combo,
        zsi:role: $role2,
        zsi:item-type: $itemType2
    )
end

# FIELD HAS SCOPE ITEM TYPE CONSTRAINT
def has-scope($fieldType, $itemType, $min, $max)
    ?assoc isa zsi:field-has-scope-item-type-constraint;
        zsi:scope-item-card-min: $min;
        zsi:scope-item-card-max: $max;
    .
    zsi:field-has-scope-item-type-constraint(
        zsi:field-type: $fieldType,
        zsi:scope-item-type: $itemType
    ) ~ ?assoc
end

# ITEM HAS FIELD WITH SCOPE ITEM CONSTRAINT
def requires-scope($itemType, $fieldType, $item, $min, $max)
    ?assoc isa zsi:item-has-field-with-scope-item-constraint;
        zsi:field-card-min: $min;
        zsi:field-card-max: $max;
    .
    zsi:item-has-field-with-scope-item-constraint(
        zsi:item-type: $itemType,
        zsi:field-type: $fieldType,
        zsi:scope-item: $item
    ) ~ ?assoc
end

# REIFIER CONSTRAINT
#--- reifiable cannot be instantiated
def cannot-have-reifier($reifiable)
    reifier-cardinality($reifiable,0,0)
end
#--- Construct of type $reifiable optionally has a reifier.
#--- If instantiated as an item,
#--- $reifiable must reify a construct of the same type
def may-have-reifier($reifiable)
    reifier-cardinality($reifiable,0,1)
end
#--- Constructs of type $reifiable must be reified
#--- by an item of type $reifiable and vice versa.
def must-have-reifier($reifiable)
    reifier-cardinality($reifiable,1,1)
end
def reifier-cardinality($reifiable,$min,$max)
    ?assoc isa zsi:reifier-constraint;
        zsi:reifier-card-min: $min;
        zsi:reifier-card-max: $max;
    .
    zsi:reifier-constraint(
        zsi:reifiable-construct-type: $reifiable
    ) ~ ?assoc
end

# UNIQUE VALUE CONSTRAINT
def has-unique-value($propType)
    ?assoc isa zsi:unique-value-constraint;
    .
    zsi:unique-value-constraint(
        zsi:constrained-property-type: $propType
    ) ~ ?assoc
end

# REGULAR EXPRESSION CONSTRAINT
def matches-regexp($propType, $regexp)
    ?assoc isa zsi:regular-expression-constraint;
        zsi:regexp: $regexp;
    .
    zsi:regular-expression-constraint(
        zsi:property-type: $propType
    ) ~ ?assoc
end
